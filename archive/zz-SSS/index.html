<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><meta name="google-site-verification" content="NaytRH7PCHM8SH9XV-xgMLEi_1m1wS9lPBAIvTJ-wvs"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="//yegor256.github.io/tacit/tacit.min.css"/><link rel="stylesheet" href="/css/custom.css"/><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-93527069-1', 'auto');
ga('send', 'pageview');
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    jax: [
        "input/TeX",
        "input/MathML",
        "input/AsciiMath",
        "output/CommonHTML"
    ],
    extensions: [
        "tex2jax.js",
        "mml2jax.js",
        "asciimath2jax.js",
        "MathMenu.js",
        "MathZoom.js",
        "AssistiveMML.js"
    ],
    TeX: {
        extensions: [
            "AMSmath.js",
            "AMSsymbols.js",
            "noErrors.js",
            "noUndefined.js"
        ]
    },
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
    },
    "HTML-CSS": {
        availableFonts: ["TeX"]
    }
});
</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script><title>General Secure Multi-Party Computation from any Linear Secret-Sharing Scheme</title></head><body><nav><input id="nav-trigger" class="nav-trigger" type="checkbox" checked="checked"/><ul><li><a href="/"><img src="/images/logo.png" height="64" width="64" alt="Home" title="Home"/></a></li><li><a href="/archive">archive</a></li><li><a href="/tags">tags</a></li><li><a href="/faq">faq</a></li><li><a href="/document">library</a></li><li><a href="/potential-topics">topics</a></li></ul><label for="nav-trigger"></label></nav><section><article><p>This talk on General Secure Multi-Party Computation from any Linear Secret-Sharing Scheme was held on Friday February 17, 2017 in MC 4045. The speaker was Zihao Zhu.</p><h2>Abstract</h2><div><p>As more and more sensitive data gets digitized, there is a need to ensure privacy  and reliability of the data, especially in the face of adversarial parties who  attempt to corrupt or unwanted access to sensitive secrets.</p><p>In many instances such as online gambling, bidding, and even Google&#39;s targeted  advertisements, a client wants to be able to take inputs from multiple sources  (for example, auction bids) and produce an output (for example, the highest bidder) without revealing any information about the other inputs.  We will use such  scenarios as well as more cryptography related ones in order to motivate  Multi-Party Computation as a method to compute on encrypted data.  With MPC, we  will quickly see it&#39;s limitations with unsecure channels and first develop secret  sharing schemes (specifically linear secret sharing schemes) such as Shamir&#39;s  scheme, and soon after, verifiable secret sharing schemes.</p><p>We will introduce the different types of adversarial structures and explore both  the robustness and limitations of secret sharing schemes against them.</p><p>Finally, we will show that all Linear Secret Sharing Schemes can be constructed  to be verifiable.  We will explore the consequences of this and discuss techniques in their construction.</p><p>Prereqs: Math136 used in proofs</p></div><h2>Summary</h2><div><p>Encrypted data requires a key to be accessed again yet storing that key in one place is very insecure.  The server storing the key could be shutdown, and lost forever, thus preventing us from ever decrypting our data and using it in a meaningful way.  In order to prevent this, we could store multiple copies of the key.  However, with more servers, the more likely one of them is to being attacked, leading to unwanted party gaining access to one of our keys and thus being able to decrypt our data.  Thus instead of storing copies of our key, we should store fragments of our key that could be recombined to form the original.  This is an example of <a href="https://u.cs.biu.ac.il/~lindell/research-statements/tutorial-secure-computation.ppt">Multi-Party Computation</a>, a process in which multiple parties give an input to a process to compute a final value.  Another simple example of a Multi-Party Computation would be in an online auction, each player sends a bid to a central server that computes the winner by finding the max bid. </p><p>The problem now becomes that of figuring out how to break up our secret into parts that individually give no information about our secret but combined reveal our original secret.  One famous  implementation of such a scheme is &quot;Sharmir&#39;s Secret Sharing Scheme&quot;.  In this Secret Sharing Scheme, we have an extra party, a dealer, who knows the secret and constructs a degree <span>$t$</span> polynomial of the form <span>$a + c_1x^1+ \dots + c_t x^t$</span> where our secret is <span>$a$</span>.  First note that in this scheme, our secret must be a number but we can always use this number to represent ASCII/Unicode value(s) to convert it to any string.   Furthermore, each individual point alone tells us nothing about the polynomial.  In fact, even having <span>$t$</span> points tells us  nothing about the actual polynomial.  However, having <span>$t+1$</span> or more points would allow one to use a <a href="https://en.wikipedia.org/wiki/Lagrange_polynomial">Lagrange Interpolation</a> to recreate the  original polynomial and thus tell us the value of <span>$a$</span>.  Then the dealer distributes at least <span>$t+1$</span> unique points, <span>$1$</span> to each party such that none of the points are <span>$(0,a)$</span> as then the holder of that point will bypass the entire scheme and know the secret.</p><p>This is a great process as we can now distribute shares of our key to as many people as we want by choosing a larger enough <span>$t$</span> and have each of the share holders send their share back to us when we want to reconstruct the secret.  However, this scheme makes one big assumption, that the players and dealer are trustworthy.  What if one of the players were compromised and  reported a point different from what they were given.  Or, what if the dealer was compromised?  We would then need verifiable secret sharing, the ability to detect when a dishonest action has been made, how/when to report it and how to proceed.  An example of such a scheme can be found <a href="https://www.win.tue.nl/~berry/papers/crypto99.pdf">here</a>.</p><p>Note that Sharmir&#39;s Secret Sharing Scheme was a linear secret sharing scheme which is when the shares are computed as a fixed linear function of the secret and some random field elements chosen by the dealer where the secret is also in the field and the field is finite.  It is shown <a href="http://www.iacr.org/archive/eurocrypt2000/1807/18070321-new.pdf">here</a> that we can convert linear secret sharing schemes into verifiable secret sharing schemes.</p></div><h2>Tags</h2><ul><li><a class="tag-link tag-computer-science" href="/tag/computer-science">computer science</a></li><li><a class="tag-link tag-cryptography" href="/tag/cryptography">cryptography</a></li></ul></article></section></body></html>
