<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><meta name="google-site-verification" content="NaytRH7PCHM8SH9XV-xgMLEi_1m1wS9lPBAIvTJ-wvs"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="//wumss.github.io/rabbit/rabbit.min.css"/><link rel="stylesheet" href="/css/custom.css"/><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-93527069-1', 'auto');
ga('send', 'pageview');
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    jax: [
        "input/TeX",
        "input/MathML",
        "input/AsciiMath",
        "output/CommonHTML"
    ],
    extensions: [
        "tex2jax.js",
        "mml2jax.js",
        "asciimath2jax.js",
        "MathMenu.js",
        "MathZoom.js",
        "AssistiveMML.js"
    ],
    TeX: {
        extensions: [
            "AMSmath.js",
            "AMSsymbols.js",
            "noErrors.js",
            "noUndefined.js"
        ]
    },
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
    },
    "HTML-CSS": {
        availableFonts: ["TeX"]
    }
});
</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script><title>Computer science</title></head><body><header><nav><input id="nav-trigger" class="nav-trigger" type="checkbox" checked="checked"/><ul><li><a href="/"><img src="/images/logo.png" height="64" width="64" alt="Home" title="Home"/></a></li><li><a href="/archive/">archive</a></li><li><a href="/tag/">tags</a></li><li><a href="/faq/">faq</a></li><li><a href="/document/">library</a></li><li><a href="/potential-topics/">topics</a></li></ul><label for="nav-trigger"></label></nav></header><main><article><h1>Computer science</h1><div><p><a href="https://en.wikipedia.org/wiki/Computer_science">Computer Science</a> covers a wide variety of topics related to computers. Both theoretical and practical fields of computer science are covered under this tag.</p></div><p>There have been 11 completed talks and 32 topic suggestions tagged with <b>computer science</b>.</p><p>There are many subfields of <b>computer science</b>, including: </p><ul><li><a class="tag-link tag-tech-talks" href="/tag/tech-talks/">Tech Talks</a></li><li><a class="tag-link tag-algorithm" href="/tag/algorithm/">algorithm</a></li><li><a class="tag-link tag-theoretical-computer-science" href="/tag/theoretical-computer-science/">theoretical computer science</a></li><li><a class="tag-link tag-computability" href="/tag/computability/">computability</a></li><li><a class="tag-link tag-efficiency" href="/tag/efficiency/">efficiency</a></li><li><a class="tag-link tag-computational-mathematics" href="/tag/computational-mathematics/">computational mathematics</a></li><li><a class="tag-link tag-type-theory" href="/tag/type-theory/">type theory</a></li><li><a class="tag-link tag-automaton" href="/tag/automaton/">automaton</a></li><li><a class="tag-link tag-computational-complexity" href="/tag/computational-complexity/">computational complexity</a></li><li><a class="tag-link tag-data-structure" href="/tag/data-structure/">data structure</a></li><li><a class="tag-link tag-functional-programming" href="/tag/functional-programming/">functional programming</a></li><li><a class="tag-link tag-distributed-system" href="/tag/distributed-system/">distributed system</a></li></ul><h2>Related Tags</h2><ul><li><a class="tag-link tag-first-year-friendly" href="/tag/first-year-friendly/">first year friendly</a></li><li><a class="tag-link tag-tech-talks" href="/tag/tech-talks/">Tech Talks</a></li><li><a class="tag-link tag-algorithm" href="/tag/algorithm/">algorithm</a></li><li><a class="tag-link tag-theoretical-computer-science" href="/tag/theoretical-computer-science/">theoretical computer science</a></li><li><a class="tag-link tag-cryptography" href="/tag/cryptography/">cryptography</a></li><li><a class="tag-link tag-logic" href="/tag/logic/">logic</a></li><li><a class="tag-link tag-computability" href="/tag/computability/">computability</a></li><li><a class="tag-link tag-efficiency" href="/tag/efficiency/">efficiency</a></li></ul><h2>Completed Talks</h2><h3><a href="/archive/lb-automatic">Automatic sequences</a></h3><p>Delivered by Laindon Burnett on Wednesday October 25, 2017</p><p>This talk will begin with a brief overview behind the theory of words in mathematics as well as the theory of finite automata in theoretical computer science. After this, we will define what an automatic sequence is, prove some fundamental theorems about them, and investigate some of their more intriguing properties. The majority of information presented comes from the text “Automatic Sequences: Theory, Applications, Generalisations” by Jean-Paul Allouche and the University of Waterloo&#39;s own Jeffrey Shallit, from the department of Computer Science.</p><p>The speaker has provided <a href="/assets/automatic-sequences.pdf">a PDF document</a> covering the same content as this talk.</p><h3><a href="/archive/fb-stable">A 3/2-approximation algorithm for the stable marriage problem with ties</a></h3><p>Delivered by Felix Bauckholt on Wednesday October 4, 2017</p><p>I will introduce the Stable Marriage Problem, and its NP-complete cousin, the Stable Marriage Problem with ties. I will present a simplified version of Király’s 3/2-approximation algorithm, which archieves the best approximation ratio known.</p><p>The <a href="/assets/stable-marriage-approximation.pdf">slides for this presentation</a> are available.</p><h3><a href="/archive/fr-MEDR">Metric embeddings and dimensionality reduction</a></h3><p>Delivered by Frieda Rong on Friday March 31, 2017</p><p>In this talk, we consider embeddings which preserve the pairwise distances of a set of points.  It is often useful to find mappings from one high dimensional space to a lower dimensional space that preserve the geometry of the points. One source of applications is in streaming large amounts of data, for which storage is costly and/or impractical. However, the study of such embeddings has also inspired developments in the design of approximation algorithms and compressed sensing.</p><p>At the crux of the talk is the remarkable Johnson-Lindenstrauss lemma. This fundamental result shows that for Euclidean spaces, it is possible to achieve significant dimensionality reduction of a set of points while approximately preserving the pairwise distances. An elementary proof will be given, along  with subsequent speed improvements with sparse projections and an interesting use of the Fourier transform. We will also discuss applications of the lemma to the fields mentioned above.</p><h3><a href="/archive/lm-BF">Bloom Filters and Other Probabilistic Data Structures</a></h3><p>Delivered by Luthfi Mawarid on Friday March 3, 2017</p><p>With the advent of big data, the ability to process large volumes of data is becoming increasingly important. For instance, when dealing with large data sets, we may want to perform simple operations such as counting the number of unique elements or checking whether or not an element is present in the set. While there are deterministic data structures, such as hash tables, that can perform these quickly, the sheer size of the data involved makes their use largely  impractical and unscalable.Instead, we may want to trade-off some accuracy in our  answers in exchange for greater space efficiency and ease of parallelization.  For this, we introduce the concept of probabilistic data structures. </p><p>In this talk, we will mainly focus on Bloom filters, which are commonly used to test set membership and speed up data access. We will explore its main use cases, its implementation details, and the mathematics behind it. If time permits, I will also talk about the count min-sketch, used for frequency counting, and/or the HyperLogLog counter, used for cardinality estimation.</p><p>This talk will assume basic knowledge of probability.</p><h3><a href="/archive/ah-TFP">Total Functional Programming</a></h3><p>Delivered by Adam Hofmann on Friday March 3, 2017</p><p>Total functional programming is a paradigm of functional programming with the additional restriction that all functions must be total; that is, every function is defined for every element of its domain.</p><p>The immediate benefits of total functional programming are clear; every function in a total language is guaranteed to terminate and not cause a runtime error. This talk will cover the basics of writing and understanding functions that are total, as well as benefits that come from having totality.</p><p>Also in the scope of this talk is the major trade offs of total functional programming, including Turing completeness and things like input and output that seem unattainable. This is accompanied by strategies to write functions with non-trivial proofs of termination such that totality is guaranteed and verifiable by the interpreter.</p><h3><a href="/archive/zz-SSS">General Secure Multi-Party Computation from any Linear Secret-Sharing Scheme</a></h3><p>Delivered by Zihao Zhu on Friday February 17, 2017</p><p>As more and more sensitive data gets digitized, there is a need to ensure privacy  and reliability of the data, especially in the face of adversarial parties who  attempt to corrupt or unwanted access to sensitive secrets.</p><p>In many instances such as online gambling, bidding, and even Google&#39;s targeted  advertisements, a client wants to be able to take inputs from multiple sources  (for example, auction bids) and produce an output (for example, the highest bidder) without revealing any information about the other inputs.  We will use such  scenarios as well as more cryptography related ones in order to motivate  Multi-Party Computation as a method to compute on encrypted data.  With MPC, we  will quickly see it&#39;s limitations with unsecure channels and first develop secret  sharing schemes (specifically linear secret sharing schemes) such as Shamir&#39;s  scheme, and soon after, verifiable secret sharing schemes.</p><p>We will introduce the different types of adversarial structures and explore both  the robustness and limitations of secret sharing schemes against them.</p><p>Finally, we will show that all Linear Secret Sharing Schemes can be constructed  to be verifiable.  We will explore the consequences of this and discuss techniques in their construction.</p><p>Prereqs: Math136 used in proofs</p><p><a href="/archive/zz-SSS">A summary of this talk is available here.</a></p><h3><a href="/archive/bz-Bitcoin">Bitcoin and the Blockchain</a></h3><p>Delivered by Ben Zhang on Friday February 17, 2017</p><p>In this talk, we will learn about the principles behind the Double Spend Problem, the Blockchain, and explore the various ways this technology is being used today.</p><p>Transferring money in the physical world is easy. However, the transfer of virtual currency is not as easy to validate. The Double Spend Problem has long stood in the way of a free (libre et gratis) virtual currency, and the world found a need for a third party (usually in the form of large banks) to validate all virtual transactions. </p><p>In 2008, a mysterious individual known as Satoshi Nakamoto published a paper titled &quot;Bitcoin: A Peer-to-Peer Electronic Cash System&quot; which describes a system for virtual transactions to be validated through the distributed computing power of the community. The system, known as the Blockchain, uses hashing and non-deterministic mathematics to protect itself from Double Spending attacks. Nakamoto&#39;s paper led to the creation of free online currencies such Bitcoin, Litecoin, and Ethereum, which are used in marketplaces today.</p><p>Prerequisite Information: Middle school math.</p><h3><a href="/archive/mp-QC">Quantum Computing</a></h3><p>Delivered by Michael Pang on Friday February 10, 2017</p><p>Introduction to quantum computing. We start off by tackling a classical problem via deterministic and probabilistic computation and then motivate a quantum model of computation. Along the way we lay out some of the mathematics needed to describe quantum computation and how it corresponds to key concepts in quantum mechanics such as interference and superposition.</p><h3><a href="/archive/ak-ReinforcementLearning">Reinforcement Learning in Games</a></h3><p>Delivered by Agastya Kalra on Friday October 21, 2016</p><h3><a href="/archive/lm-CategoryTheory">Category Theory</a></h3><p>Delivered by Luthfi Mawarid on Friday October 21, 2016</p><p>This talk will cover the very basics of Category Theory, motivated by simple examples using the category of sets. I will then introduce some applications to other areas of mathematics, such as linear algebra and programming language theory.</p><h3><a href="/archive/nk-Types">Types and Object-Oriented Programming</a></h3><p>Delivered by Nikita Kapustin on Friday October 14, 2016</p><p>I&#39;ll be talking about how to use basic types like sets and functions to construct other types and use them to represent objects.</p><h2 id="suggestions">Talk Suggestions</h2><h3>Abstraction in Technical Computing</h3><div><p>Scientists, mathematicians, and engineers have an increasing need to write efficient computer programs but they tend to use specific languages for technical computing like Matlab or Mathematica rather than general purpose languages. The suggested reference discusses the properties a general purpose language would need to be able to also handle technical computing – one possibility for allowing efficient technical computing involves a powerful type system and dispatch system to enable generic, staged, and higher-order programming.</p><p><strong>Required</strong> <strong>Background:</strong> First year CS at the level of CS 135 and 136.</p></div><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="https://github.com/JeffBezanson/phdthesis/blob/master/main.pdf">Jeffrey Werner Bezanson</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Abstraction in Technical Computing" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Abstraction in Technical Computing" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-tech-talks" href="/tag/tech-talks/">Tech Talks</a> <a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-first-year-friendly" href="/tag/first-year-friendly/">first year friendly</a> <a class="tag-link tag-polymorphism" href="/tag/polymorphism/">polymorphism</a> <a class="tag-link tag-programming-language" href="/tag/programming-language/">programming language</a> <a class="tag-link tag-type-theory" href="/tag/type-theory/">type theory</a> </p><h3>Automated Verification of Computational Systems</h3><div><p>It was realized in the 1960s that mathematical logic provides a suitable language to formulate properties of programs. This idea was formalized by Hoare who developed <em>Hoare logic</em> as a means to prove program correctness. However, this technique didn&#39;t apply directly to concurrent programs. An alternative approach called <em>Temporal Logic</em> was proposed by Amir Pneuli in 1977 which did provide a means to reason about concurrent programs. This topic studies this and then delves into the fundamental ideas behind model checking.</p><p><strong>Required Background:</strong> Basics of computer science at the level of CS 146, Logic at the level of CS 245.</p></div><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="http://www.cmi.ac.in/~madhavan/papers/pdf/resonance-jul2009.pdf">Madhavan Mukund</a></p></div></li><li><div><p>Grumberg, O., &amp; Veith, H. (Eds.). (2008). 25 years of model checking: history, achievements, perspectives (Vol. 5000). Springer.</p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Automated Verification of Computational Systems" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Automated Verification of Computational Systems" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-logic" href="/tag/logic/">logic</a> <a class="tag-link tag-model-checking" href="/tag/model-checking/">model checking</a> </p><h3>Bloom Filters and Probabilistic Data Structures</h3><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="https://www.cs.dal.ca/sites/default/files/technical_reports/CS-2002-10.pdf">Blustein</a></p></div></li></ul><p>Past and scheduled talks on a related subject include</p><ul><li><span><a href="/archive/lm-BF">Bloom Filters and Other Probabilistic Data Structures</a> by Luthfi Mawarid</span></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Bloom Filters and Probabilistic Data Structures" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Bloom Filters and Probabilistic Data Structures" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-algorithm" href="/tag/algorithm/">algorithm</a> <a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-data-structure" href="/tag/data-structure/">data structure</a> <a class="tag-link tag-probability" href="/tag/probability/">probability</a> <a class="tag-link tag-space-efficiency" href="/tag/space-efficiency/">space efficiency</a> </p><h3>Cake cutting algorithms</h3><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="https://www.amazon.com/Cake-Cutting-Algorithms-Fair-You-Can/dp/1568810768/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1480468807&amp;sr=1-1&amp;keywords=cake+cutting+algorithms">Robertson, Webb</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Cake cutting algorithms" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Cake cutting algorithms" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-algorithm" href="/tag/algorithm/">algorithm</a> <a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-economics" href="/tag/economics/">economics</a> <a class="tag-link tag-first-year-friendly" href="/tag/first-year-friendly/">first year friendly</a> <a class="tag-link tag-game-theory" href="/tag/game-theory/">game theory</a> <a class="tag-link tag-optimization" href="/tag/optimization/">optimization</a> <a class="tag-link tag-recreational-mathematics" href="/tag/recreational-mathematics/">recreational mathematics</a> <a class="tag-link tag-social-choice" href="/tag/social-choice/">social choice</a> </p><h3>Completeness, Incompleteness, and Turing Machines</h3><div><p>This topic studies the connection between Godels&#39;s incompleteness theorems and turing machines and how each implies the other</p></div><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="http://www.scottaaronson.com/democritus/lec3.html">Scott Aaronson</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Completeness, Incompleteness, and Turing Machines" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Completeness, Incompleteness, and Turing Machines" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-computability" href="/tag/computability/">computability</a> <a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-incompleteness" href="/tag/incompleteness/">incompleteness</a> <a class="tag-link tag-logic" href="/tag/logic/">logic</a> <a class="tag-link tag-theoretical-computer-science" href="/tag/theoretical-computer-science/">theoretical computer science</a> <a class="tag-link tag-turing-machine" href="/tag/turing-machine/">turing machine</a> </p><h3>Complex Event Processing Systems</h3><div><p>The ever-increasing amount of information that needs to be processed has led to the development of Complex Event Processing systems such as Apache Storm or Twitter Heron. These systems distribute a workload over many machines in a cluster, and offer both efficiency and fault-tolerance.</p></div><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="https://storm.apache.org">Apache Storm</a></p></div></li><li><div><p>Kulkarni, S., Bhagat, N., Fu, M., Kedigehalli, V., Kellogg, C., Mittal, S., ... &amp; Taneja, S. (2015, May). Twitter heron: Stream processing at scale. In Proceedings of the 2015 ACM SIGMOD International Conference on Management of Data (pp. 239-250). ACM. doi:10.1145/2723372.2742788</p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Complex Event Processing Systems" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Complex Event Processing Systems" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-tech-talks" href="/tag/tech-talks/">Tech Talks</a> <a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-data-science" href="/tag/data-science/">data science</a> <a class="tag-link tag-distributed-system" href="/tag/distributed-system/">distributed system</a> <a class="tag-link tag-first-year-friendly" href="/tag/first-year-friendly/">first year friendly</a> <a class="tag-link tag-parallel-computing" href="/tag/parallel-computing/">parallel computing</a> <a class="tag-link tag-statistics" href="/tag/statistics/">statistics</a> </p><h3>Complexity of Matrix Multiplication</h3><div><p>Volker Strassen showed that <span>$n^3$</span> matrix multiplication was not optimal in 1969. Since then, new algorithms such as Coppersmith-Winograd have further improved the time complexity of matrix multiplication. It is conjectured that matrix multiplication is possible in <span>$O(n^{2+ɛ})$</span> for any <span>$ɛ&gt;0$</span>, however small. This is one of the few remaining open problems in finite-dimensional linear algebra.</p></div><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="http://www.cs.umd.edu/~gasarch/TOPICS/ramsey/matrixmult.pdf">Don Coppersmith and Shmuel Winograd</a></p></div></li><li><div><p><a href="http://ieeexplore.ieee.org/document/1530730/?section=abstract&amp;part=1">H. Cohn, R. Kleinberg, B. Szegedy and C. Umans, &quot;Group-theoretic algorithms for matrix multiplication,&quot; 46th Annual IEEE Symposium on Foundations of Computer Science (FOCS&#39;05), 2005, pp. 379-388. doi: 10.1109/SFCS.2005.39</a></p></div></li><li><div><p><a href="http://www.maths.ed.ac.uk/sites/default/files/atoms/files/stothers.pdf">Andrew James Stothers, On The Complexity of Matrix Multiplication</a></p></div></li><li><div><p><a href="https://galton.uchicago.edu/mart/slides/Umans-talk-1.pdf">Chris Umans, Approaches to bounding the exponent of matrix multiplication</a></p></div></li><li><div><p><a href="https://www.ma.utexas.edu/users/horem/gtpmm.pdf">Richard Strong Bowen, Bob Chen, Hendrik Orem, and Martijn van Schaardenburg: Group-Theoretic Partial Matrix Multiplication</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Complexity of Matrix Multiplication" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Complexity of Matrix Multiplication" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-algebra" href="/tag/algebra/">algebra</a> <a class="tag-link tag-algorithm" href="/tag/algorithm/">algorithm</a> <a class="tag-link tag-computational-mathematics" href="/tag/computational-mathematics/">computational mathematics</a> <a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-group-theory" href="/tag/group-theory/">group theory</a> <a class="tag-link tag-linear-algebra" href="/tag/linear-algebra/">linear algebra</a> <a class="tag-link tag-open-problem" href="/tag/open-problem/">open problem</a> </p><h3>Constructive Mathematics</h3><div><p>Constructive mathematics, or mathematics without the law of the excluded middle, is becoming more popular thanks to connections with computer science, category theory, and topology. Its logical foundations may be initially difficult to grasp for those used to a classical system.</p></div><p>Possible reference materials for this topic include</p><ul><li><div><p>(Talk) <a href="https://www.youtube.com/watch?v=zmhd8clDd_Y">Andrej Bauer, Five Stages of Accepting Constructive Mathematics</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Constructive Mathematics" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Constructive Mathematics" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-computability" href="/tag/computability/">computability</a> <a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-constructive-mathematics" href="/tag/constructive-mathematics/">constructive mathematics</a> <a class="tag-link tag-logic" href="/tag/logic/">logic</a> <a class="tag-link tag-philosophy" href="/tag/philosophy/">philosophy</a> <a class="tag-link tag-topology" href="/tag/topology/">topology</a> <a class="tag-link tag-type-theory" href="/tag/type-theory/">type theory</a> </p><h3>Conway’s Game of Life</h3><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="http://web.mit.edu/sp.268/www/2010/lifeSlides.pdf">Melissa Gymrek</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Conway’s Game of Life" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Conway’s Game of Life" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-automaton" href="/tag/automaton/">automaton</a> <a class="tag-link tag-cellular-automaton" href="/tag/cellular-automaton/">cellular automaton</a> <a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-first-year-friendly" href="/tag/first-year-friendly/">first year friendly</a> <a class="tag-link tag-recreational-mathematics" href="/tag/recreational-mathematics/">recreational mathematics</a> <a class="tag-link tag-theoretical-computer-science" href="/tag/theoretical-computer-science/">theoretical computer science</a> </p><h3>Curry–Howard–Lambek Correspondence</h3><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="http://www.math.helsinki.fi/logic/sellc-2010/course/LectureIII.pdf">Samson Abramsky</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Curry–Howard–Lambek Correspondence" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Curry–Howard–Lambek Correspondence" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-category-theory" href="/tag/category-theory/">category theory</a> <a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-logic" href="/tag/logic/">logic</a> </p><h3>Dealing with Missing Data</h3><div><p>Data are rarely perfect. Robust data science tools must have ways to deal with missing data. However, this is not always easy. A balance must be struck between performance and convenience.</p></div><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="https://en.wikipedia.org/wiki/Missing_data">Wikipedia</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Dealing with Missing Data" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Dealing with Missing Data" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-tech-talks" href="/tag/tech-talks/">Tech Talks</a> <a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-data-science" href="/tag/data-science/">data science</a> <a class="tag-link tag-efficiency" href="/tag/efficiency/">efficiency</a> <a class="tag-link tag-first-year-friendly" href="/tag/first-year-friendly/">first year friendly</a> <a class="tag-link tag-statistics" href="/tag/statistics/">statistics</a> </p><h3>Galois Field Arithmetic</h3><div><p>A Galois field is a finite field and are used in a variety of applications, including in classical coding theory and cryptography algorithms. This topic studies how to efficiently optimize arithmetic in such fields.</p></div><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="http://web.eecs.utk.edu/~plank/plank/papers/FAST-2013-GF.html">Plank, Greenan, Miller</a></p></div></li><li><div><p><a href="https://www.math.washington.edu/~morrow/336_12/papers/juan.pdf">Christoforus Juan Benvenuto</a></p></div></li><li><div><p><a href="http://www.springer.com/?SGWID=4-102-45-110359-0">Finite Field Arithmetic</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Galois Field Arithmetic" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Galois Field Arithmetic" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-algebra" href="/tag/algebra/">algebra</a> <a class="tag-link tag-algorithm" href="/tag/algorithm/">algorithm</a> <a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-cryptography" href="/tag/cryptography/">cryptography</a> <a class="tag-link tag-efficiency" href="/tag/efficiency/">efficiency</a> <a class="tag-link tag-field-theory" href="/tag/field-theory/">field theory</a> </p><h3>Geographic Authentication Schemes</h3><div><p>Users often choose passwords that are easy to remember but also easy to guess. Both textual and graphical passwords have failed to provide a viable solution to this usability-security tension. It thus remains a critical challenge in password research to design an authentication scheme that is resilient to guessing attacks while offering good memorability.</p></div><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="http://www.cs.toronto.edu/~abari/papers/GeoPass_TIFS_2016.pdf">Macrae, et all</a></p></div></li><li><div><p><a href="https://arxiv.org/pdf/1408.2852.pdf">Al Ameen, Wright</a></p></div></li><li><div><p><a href="https://cups.cs.cmu.edu/soups/2013/proceedings/a14_Thorpe.pdf">Thorpe, et all</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Geographic Authentication Schemes" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Geographic Authentication Schemes" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-encryption" href="/tag/encryption/">encryption</a> <a class="tag-link tag-human-computer-interaction" href="/tag/human-computer-interaction/">human-computer interaction</a> <a class="tag-link tag-security" href="/tag/security/">security</a> </p><h3>Gillespie Algorithm</h3><div><p>The Gillespie Algorithm for stochastic equations is used heavily in a number of fields of applied mathematics, in particular computational systems biology.</p></div><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="https://www.cs.princeton.edu/picasso/seminarsS05/Karig_slides.pdf">David Karig</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Gillespie Algorithm" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Gillespie Algorithm" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-algorithm" href="/tag/algorithm/">algorithm</a> <a class="tag-link tag-applied-mathematics" href="/tag/applied-mathematics/">applied mathematics</a> <a class="tag-link tag-computational-mathematics" href="/tag/computational-mathematics/">computational mathematics</a> <a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-differential-equation" href="/tag/differential-equation/">differential equation</a> <a class="tag-link tag-probability" href="/tag/probability/">probability</a> <a class="tag-link tag-stochastic-equation" href="/tag/stochastic-equation/">stochastic equation</a> </p><h3>Hindley–Milner Type System</h3><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="http://www.jstor.org/stable/1995158">R. Hindley</a></p></div></li><li><div><p><a href="http://dev.stephendiehl.com/fun/006_hindley_milner.html">Stephen Diehl</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Hindley–Milner Type System" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Hindley–Milner Type System" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-type-theory" href="/tag/type-theory/">type theory</a> </p><h3>IEEE 754-2008: Floating Point Arithmetic</h3><div><p>Most programming languages provide a floating-point type. What is floating point, and how does it work? What caveats should programmers be aware of?</p></div><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="https://en.wikipedia.org/wiki/IEEE_floating_point">IEEE floating point on Wikipedia</a></p></div></li><li><div><p><a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=IEEE 754-2008: Floating Point Arithmetic" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=IEEE 754-2008: Floating Point Arithmetic" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-tech-talks" href="/tag/tech-talks/">Tech Talks</a> <a class="tag-link tag-computational-mathematics" href="/tag/computational-mathematics/">computational mathematics</a> <a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-first-year-friendly" href="/tag/first-year-friendly/">first year friendly</a> <a class="tag-link tag-floating-point-number" href="/tag/floating-point-number/">floating point number</a> </p><h3>Lindenmeyer systems</h3><div><p>Originally developed to model plant growth, L-systems are a logical approach to various scientific questions, as well as one of many ways to generate artistically pleasing fractals.</p></div><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="https://en.wikipedia.org/wiki/L-system">L-system. In Wikipedia, the free encyclopedia.</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Lindenmeyer systems" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Lindenmeyer systems" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-art" href="/tag/art/">art</a> <a class="tag-link tag-biology" href="/tag/biology/">biology</a> <a class="tag-link tag-botany" href="/tag/botany/">botany</a> <a class="tag-link tag-computability" href="/tag/computability/">computability</a> <a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-fractal" href="/tag/fractal/">fractal</a> <a class="tag-link tag-logic" href="/tag/logic/">logic</a> <a class="tag-link tag-theoretical-computer-science" href="/tag/theoretical-computer-science/">theoretical computer science</a> </p><h3>P vs. NP</h3><p>Possible reference materials for this topic include</p><ul><li><div><p>Arora, Bazak: Computational Complexity</p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=P vs. NP" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=P vs. NP" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-computability" href="/tag/computability/">computability</a> <a class="tag-link tag-computational-complexity" href="/tag/computational-complexity/">computational complexity</a> <a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-open-problem" href="/tag/open-problem/">open problem</a> <a class="tag-link tag-theoretical-computer-science" href="/tag/theoretical-computer-science/">theoretical computer science</a> </p><h3>Predicate Dispatch</h3><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="ftp://publications.ai.mit.edu/ai-publications/2001/AITR-2001-006.pdf">Aaron Mark Ucko</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Predicate Dispatch" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Predicate Dispatch" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-polymorphism" href="/tag/polymorphism/">polymorphism</a> </p><h3>Presburger Arithmetic</h3><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.16.9759">Michael J. Fischer and Michael O. Rabin, Super-Exponentional Complexity of Presburger Arithmetic.</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Presburger Arithmetic" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Presburger Arithmetic" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-computability" href="/tag/computability/">computability</a> <a class="tag-link tag-computational-complexity" href="/tag/computational-complexity/">computational complexity</a> <a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-logic" href="/tag/logic/">logic</a> <a class="tag-link tag-theoretical-computer-science" href="/tag/theoretical-computer-science/">theoretical computer science</a> </p><h3>Protein Structure Prediction</h3><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="http://folding.stanford.edu/home/papers">Folding@Home Papers Collection</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Protein Structure Prediction" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Protein Structure Prediction" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-biology" href="/tag/biology/">biology</a> <a class="tag-link tag-chemistry" href="/tag/chemistry/">chemistry</a> <a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-optimization" href="/tag/optimization/">optimization</a> </p><h3>Purely Functional Data Structures</h3><div><p>Persistent (or purely function) data structures are those whose operations do not mutate the existing data structure, but rather create a new data structure that might share some state. These data structures are useful because there is no need to copy memory; rather the data structure can be shared among multiple objects. Techniques for making these data structures fast, memory-efficient, or real-time are an active area of research in functional programming.</p></div><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="http://www.math.tau.ac.il/~haimk/adv-ds-2000/jacm-final.pdf">Haim Kapland and Robert E. Tarjan, Purely Functional, Real-Time Deques with Catenation</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Purely Functional Data Structures" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Purely Functional Data Structures" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-data-structure" href="/tag/data-structure/">data structure</a> <a class="tag-link tag-functional-programming" href="/tag/functional-programming/">functional programming</a> </p><h3>Queueing Theory</h3><div><p>Queueing theory is the mathematical study of waiting lines, or queues. In queueing theory, a model is constructed so that queue lengths and waiting time can be predicted. Queueing theory is generally considered a branch of operations research because the results are often used when making business decisions about the resources needed to provide a service. </p></div><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="http://www.cs.ucf.edu/~lboloni/Teaching/EEL6785_Fall2010/slides/QueueingTheory.pdf">Andreas Willig</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Queueing Theory" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Queueing Theory" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-optimization" href="/tag/optimization/">optimization</a> </p><h3>Secret Sharing Schemes and Multi-party Computation Protocols</h3><p>Past and scheduled talks on a related subject include</p><ul><li><span><a href="/archive/zz-SSS">General Secure Multi-Party Computation from any Linear Secret-Sharing Scheme</a> by Zihao Zhu</span></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Secret Sharing Schemes and Multi-party Computation Protocols" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Secret Sharing Schemes and Multi-party Computation Protocols" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-cryptography" href="/tag/cryptography/">cryptography</a> <a class="tag-link tag-first-year-friendly" href="/tag/first-year-friendly/">first year friendly</a> </p><h3>Separating Words Problem</h3><div><p>Given two strings, we can write a computer program to tell them apart. A special kind of very simple computer program that accepts or rejects strings, using only a finite number of states while reading the string, is called a deterministic finite automaton. (These deterministic finite automata can also be expressed as a regular expression.) For any two strings of length <span>$n$</span>, there is some deterministic finite automaton (or regular expression) that recognizes one and not the other, and there is some smallest one. In the worst case, it is known (Robson 1989) that any two strings of length <span>$n$</span> can be separated by an automaton of size <span>$O(n^{2/5} (\log n)^{3/5})$</span>, but this is not known to be optimal. The optimal upper bound remains an open problem.</p></div><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="https://en.wikipedia.org/wiki/Separating_words_problem">Wikipedia: Separating words problem</a></p></div></li><li><div><p><a href="http://www.sciencedirect.com/science/article/pii/0020019089902159?via%3Dihub">J.M. Robson, Separating strings with small automata</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Separating Words Problem" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Separating Words Problem" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-automaton" href="/tag/automaton/">automaton</a> <a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-open-problem" href="/tag/open-problem/">open problem</a> <a class="tag-link tag-theoretical-computer-science" href="/tag/theoretical-computer-science/">theoretical computer science</a> </p><h3>Sparse Matrices</h3><div><p>Sparse matrices are frequently used in scientific and numerical computation. How do they work? What new findings have there been? Speakers are encouraged to specialize this broad topic to a particular subfield of interest.</p></div><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="http://www.maths.tcd.ie/pub/ims/nl15/nl15_6-30.pdf">Derek O&#39;Connor, An Introduction to Sparse Matrices</a></p></div></li><li><div><p><a href="http://gauss.cs.ucsb.edu/~aydin/csb2009.pdf">Aydın Buluç, Jeremy T. Fineman, Matteo Frigo, John R. Gilbert, Charles E. Leiserson</a></p></div></li><li><div><p><a href="http://faculty.cse.tamu.edu/davis/research.html">Tim Davis</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Sparse Matrices" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Sparse Matrices" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-algebra" href="/tag/algebra/">algebra</a> <a class="tag-link tag-computational-mathematics" href="/tag/computational-mathematics/">computational mathematics</a> <a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-linear-algebra" href="/tag/linear-algebra/">linear algebra</a> </p><h3>The Joy of Factoring</h3><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="https://books.google.ca/books/about/The_Joy_of_Factoring.html?id=rowCAQAAQBAJ&amp;redir_esc=y">Samuel S. Wagstaff (Jr.)</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=The Joy of Factoring" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=The Joy of Factoring" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-algorithm" href="/tag/algorithm/">algorithm</a> <a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-cryptography" href="/tag/cryptography/">cryptography</a> <a class="tag-link tag-number-theory" href="/tag/number-theory/">number theory</a> <a class="tag-link tag-quantum-algorithm" href="/tag/quantum-algorithm/">quantum algorithm</a> </p><h3>Total Functional Programming</h3><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.106.364&amp;rep=rep1&amp;type=pdf">D. A. Turner</a></p></div></li></ul><p>Past and scheduled talks on a related subject include</p><ul><li><span><a href="/archive/ah-TFP">Total Functional Programming</a> by Adam Hofmann</span></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Total Functional Programming" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Total Functional Programming" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-tech-talks" href="/tag/tech-talks/">Tech Talks</a> <a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-first-year-friendly" href="/tag/first-year-friendly/">first year friendly</a> <a class="tag-link tag-functional-programming" href="/tag/functional-programming/">functional programming</a> </p><h3>Tropical geometry and Computational Biology</h3><div><p>Tropical geometry is a combinatorial shadow of algebraic geometry, offering new polyhedral tools to compute invariants of algebraic varieties. It is based on tropical algebra, where the sum of twonumbers is their minimum and the product is their sum. This turnspolynomials into piecewise-linear functions, and their zero sets into polyhedralcomplexes.</p></div><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="https://homepages.warwick.ac.uk/staff/D.Maclagan/papers/TropicalBook20.4.14.pdf">Diane Maclagan, Bernd Sturmfels</a></p></div></li><li><div><p><a href="https://math.berkeley.edu/~bernd/mathmag.pdf">David Speyer, Bernd Strumgfels</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Tropical geometry and Computational Biology" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Tropical geometry and Computational Biology" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-algebra" href="/tag/algebra/">algebra</a> <a class="tag-link tag-algebraic-geometry" href="/tag/algebraic-geometry/">algebraic geometry</a> <a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-geometry" href="/tag/geometry/">geometry</a> </p><h3>Understanding LLVM</h3><div><p>The LLVM Compiler Infrastructure Project now powers a wide variety of software, including major programming languages including Rust and Julia, as well as compilers for the popular C and C++ programming languages. Understanding how LLVM works, and being able to read some LLVM bytecode, is extremely useful for optimizing code.</p></div><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="http://llvm.org/">The LLVM Compiler Infrastructure Project</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Understanding LLVM" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Understanding LLVM" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-tech-talks" href="/tag/tech-talks/">Tech Talks</a> <a class="tag-link tag-compiler" href="/tag/compiler/">compiler</a> <a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-efficiency" href="/tag/efficiency/">efficiency</a> <a class="tag-link tag-first-year-friendly" href="/tag/first-year-friendly/">first year friendly</a> <a class="tag-link tag-programming-language" href="/tag/programming-language/">programming language</a> </p><h3>Unique Games Conjecture</h3><div><p>The Unique Games Conjecture, if true, implies that many problems that lack exact polynomial time solutions also lack approximate polynomial time solutions. It was formulated by Subhash Khot in 2002 and is still unsolved.</p></div><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="https://www.simonsfoundation.org/mathematics-and-physical-science/approximately-hard-the-unique-games-conjecture/">Erica Klarreich, Approximately Hard: The Unique Games Conjecture</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Unique Games Conjecture" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Unique Games Conjecture" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-computational-complexity" href="/tag/computational-complexity/">computational complexity</a> <a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-open-problem" href="/tag/open-problem/">open problem</a> <a class="tag-link tag-theoretical-computer-science" href="/tag/theoretical-computer-science/">theoretical computer science</a> </p><h3>Zero-Cost Abstraction</h3><div><p>Computer science is, fundamentally, about abstraction and efficiency. A programmer would rather use high-level bricks to build a product than worry about low-level details. Regrettably, the use of high-level bricks often comes at a cost in efficiency, forcing programmers to worry about low-level details. Recently, many programming languages have begun to stress the importance of zero-cost abstractions: ways to construct high-level bricks with zero efficiency cost.</p></div><p>Possible reference materials for this topic include</p><ul><li><div><p><a href="https://blog.rust-lang.org/2015/05/11/traits.html">Abstraction without overhead: traits in Rust</a></p></div></li><li><div><p><a href="https://eschnett.github.io/julia/2016/06/23/some-thoughts-on-generic-programming-in-julia">Some thoughts on generic programming in Julia</a></p></div></li></ul><p>Quick links: <a href="https://www.google.ca/search?q=Zero-Cost Abstraction" rel="nofollow">Google search</a>, <a href="http://search.arxiv.org:8081/?query=Zero-Cost Abstraction" rel="nofollow">arXiv.org search</a>, <a href="/submit-talk">propose to present a talk</a></p><p><a class="tag-link tag-tech-talks" href="/tag/tech-talks/">Tech Talks</a> <a class="tag-link tag-abstraction" href="/tag/abstraction/">abstraction</a> <a class="tag-link tag-computer-science" href="/tag/computer-science/">computer science</a> <a class="tag-link tag-efficiency" href="/tag/efficiency/">efficiency</a> <a class="tag-link tag-first-year-friendly" href="/tag/first-year-friendly/">first year friendly</a> </p></article><footer><p>Help improve this page by <a href="https://github.com/wumss/seminar/edit/master/wiki/tag/Remarkable.Tags.Tag(&quot;computer science&quot;).md">editing it on GitHub</a>.</p></footer></main></body></html>
